# Detalle accounts

Este documento detalla el funcionamiento interno del módulo `accounts` en el sistema, centrándose en la construcción de estados de cuenta, balances progresivos, intercalación de pagos/cobros y lógica de agrupación por dimensiones.

## 1. Obtención y Construcción de Información de Pagos/Cobros

Los movimientos de caja (pagos y cobros) se gestionan a través de `AccountPaymentRepository` y se integran en los estados de cuenta diarios.

### 1.1 Fuente de Datos
Los movimientos se obtienen principalmente mediante `AccountPaymentRepository.findMovementsByDateRange`.
- **Tabla origen**: `AccountPayment` (o similar, tabla de movimientos).
- **Tipos**:
  - `payment`: Pagos recibidos.
  - `collection`: Cobros realizados.
- **Filtros**: Se filtran por rango de fechas y la `dimension` activa (banca, ventana, vendedor).

### 1.2 Movimiento "Virtual": Saldo del Mes Anterior
Para garantizar la continuidad del saldo entre meses, el sistema inyecta un movimiento virtual llamado `previous-month-balance` en el primer día del rango consultado (generalmente el 1ro del mes).
- **Cálculo**: Se obtiene mediante `getPreviousMonthFinalBalance`, que consulta el `closingBalance` del mes cerrado anterior o el `remainingBalance` del último día del mes previo.
- **Inyección**: En [getStatementDirect](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.calculations.ts#691-4077), este saldo se inserta al inicio de la lista de movimientos del primer día con el tipo `initial_balance` (o `payment` con nota "Saldo del mes anterior"). Esto asegura que el `accumulated` inicial sea correcto.

## 2. Construcción `bySorteo` por Día

El desglose por sorteo (`bySorteo`) permite ver el rendimiento de cada lotería en un día específico.

### 2.1 Proceso ([getSorteoBreakdownBatch](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.queries.ts#332-681))
1.  **Selección de Tickets**: Se buscan todos los tickets dentro del rango de fechas que cumplan con los filtros de dimensión y no estén cancelados ni excluidos.
2.  **Agrupación**: Los tickets se agrupan por `sorteoId`.
3.  **Cálculo de Totales por Sorteo**:
    -   **Ventas (`sales`)**: Suma de `totalAmount` de los tickets.
    -   **Premios (`payouts`)**: Suma de `payout` de las jugadas ganadoras (`isWinner: true`).
    -   **Comisiones**: Se suman usando los *snapshots* guardados en cada `Jugada` (`listeroCommissionAmount` y `commissionAmount` para vendedor). Esto garantiza consistencia histórica aunque cambien las políticas.
4.  **Balance del Sorteo**:
    -   Si es vista VENDEDOR: `Ventas - Premios - Comisión Vendedor`.
    -   Si es vista BANCA/VENTANA: `Ventas - Premios - Comisión Listero`.

## 3. Intercalación entre Sorteos y Pagos/Cobros

La función clave es [intercalateSorteosAndMovements](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.intercalate.ts#63-324) (en [accounts.intercalate.ts](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.intercalate.ts)). Su objetivo es presentar una línea de tiempo unificada y cronológica de todos los eventos financieros del día.

### 3.1 Unificación de Eventos
Se combinan dos listas:
1.  **Sorteos**: Tienen una fecha y hora programada (`scheduledAt`).
2.  **Movimientos**: Tienen `createdAt` o una hora específica manual (`time` en formato HH:MM).

### 3.2 Lógica de Ordenamiento y Construcción
1.  **Normalización de Hora**: Las horas de los movimientos se convierten a UTC para ser comparables con `scheduledAt` de los sorteos. Si el usuario ingresó una hora manual, esta tiene prioridad sobre `createdAt`.
2.  **Orden Cronológico (ASC)**: Se ordenan todos los eventos (sorteos y movimientos) del más antiguo al más reciente.
    -   *Criterio de desempate*: Si un sorteo y un movimiento ocurren al mismo tiempo, el saldo inicial (`initial_balance`) va primero.
3.  **Cálculo de Acumulado Progresivo (`accumulated`)**:
    -   Se inicia con un `initialAccumulated` (saldo del día anterior).
    -   Se itera la lista ordenada ASC.
    -   Para cada evento: `Nuevo Acumulado = Acumulado Anterior + Balance del Evento`.
    -   Este valor se guarda en la propiedad `accumulated` (y `sorteoAccumulated` para consistencia).
4.  **Orden Visual (DESC)**: Finalmente, la lista se invierte (más reciente primero) para su visualización en el frontend, manteniendo los valores acumulados calculados en el paso anterior.

## 4. Construcción del Acumulado Progresivo Secuencial

El sistema garantiza que el saldo sea continuo a lo largo del mes ("Saldo a Hoy").

### 4.1 Flujo en [getStatementDirect](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.calculations.ts#691-4077)
1.  **Iteración Secuencial**: Se procesan los días del mes uno por uno, en orden.
2.  **Arrastre de Saldo (`Carry Over`)**:
    -   El `remainingBalance` del Día N se convierte en el `previousAccumulated` del Día N+1.
    -   Para el Día 1, el `previousAccumulated` proviene del cierre del mes anterior.
3.  **Manejo de Días sin Ventas**: Si un día no tiene tickets (ej. un feriado o domingo sin sorteos), el sistema aún genera una entrada (o verifica los movimientos) para asegurar que el saldo se traslade correctamente al día siguiente. No se "saltan" días en el cálculo del acumulado.
4.  **Cálculo Diario**:
    -   `Balance del Día` = `Ventas - Premios - Comisiones + Pagos - Cobros`.
    -   `Remaining Balance (Saldo a Hoy)` = `Saldo Ayer + Balance del Día`.

## 5. Análisis por Scope y Dimensión

El sistema adapta los cálculos según quién consulta (`dimension`) y qué nivel de agregación se requiere (`shouldGroupByDate`).

### 5.1 Dimensiones
-   **Vendedor**: Ve sus propias ventas y comisiones (`commissionOrigin: "USER"`). Su balance descuenta su propia comisión.
-   **Ventana**: Ve el consolidado o desglose de sus vendedores. Su balance descuenta la `listeroCommission`.
-   **Banca**: Ve el consolidado global. Su balance también se basa en la `listeroCommission` (la ganancia de la banca es lo que queda después de pagar premios y comisiones a la estructura).

### 5.2 Agrupación (`shouldGroupByDate`)
-   **True (Consolidado)**: Agrupa todas las entidades (ej. "Todas las ventanas") en un solo registro por día.
    -   Se suman los totales de todas las entidades.
    -   Útil para la vista general de la Banca.
-   **False (Desglosado)**: Mantiene registros separados por entidad para cada día (ej. "Ventana A - Día 1", "Ventana B - Día 1").
    -   Útil cuando se filtra por una ventana o vendedor específico.

## 6. Obtención de Totales Esperados

Los totales finales del estado de cuenta (`StatementResponse`) se calculan agregando los resultados procesados:

1.  **Totales del Periodo (`totals`)**: Suma simple de las columnas de todos los días consultados (Ventas, Premios, Comisiones, Pagos, Cobros).
2.  **Saldo Final (`totalRemainingBalance`)**: No es una suma. Es el valor de `remainingBalance` del **último registro cronológico** del periodo consultado. Representa la deuda o haber real al corte.
3.  **Saldado vs Pendiente**: Se cuentan los días marcados como `isSettled` para dar un resumen del estado de liquidación.

---
**Resumen de Archivos Clave Analizados:**
-   [accounts.calculations.ts](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.calculations.ts): Orquestador principal, lógica de días y loops.
-   [accounts.queries.ts](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.queries.ts): Consultas SQL optimizadas para agregaciones.
-   [accounts.intercalate.ts](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts/accounts.intercalate.ts): Lógica de mezcla temporal sorteos/movimientos.
-   [accounts.service.ts](file:///c:/Users/mquir/Proyectos/Bancas/backend/src/api/v1/services/accounts.service.ts): Capa superior de servicio.
